# 小林coding计算机网络

## linux系统如何收发网络包？

**收包过程：**

1. 当有网络包到达时，会通过 DMA 技术，将网络包写入到ring buffer的环形缓冲区中，接着网卡向 CPU 发起硬中断，当 CPU 根据中断表，调用中断处理函数。
2. 中断处理函数会发起软中断，内核线程 ksoftirqd 处理软中断，会来轮询处理数据。
3. ksoftirgd 线程会从 Ring Buffer 中获取数据，作为一个网络包交给网络协议栈进行逐层处理。
4. 网络接口层：检查报文的合法性。
5. 网络层：确认这个网络包是发给本机还是转发出去。
6. 传输层取出 TCP 头或 UDP 头，根据四元组找到socket，把数据放到socket的接受缓冲区中。
7. 应用层：调用 Socket 接口，将内核的 Socket 接收缓冲区的数据拷贝到应用层的缓冲区，然后唤醒用户进程。

**发包过程与收包过程相反**

## 发送网络数据时，有几次内存拷贝？
1. 第一次，调用发送数据的系统调用的时候，内核会申请一个内核态的 sk_buff 内存，将用户待发送的数据拷贝到 sk buff 内存，然后入到发送缓冲区。
2. 第二次，在使用 TCP 传输协议的情况下，从传输层进入网络层的时候，sk_buff 会被创建副本。副本 sk_buff 会被送往网络层，等它发送完的时候释放掉，然后原始的 sk buf 还保留在传输层，目的是为了实现 TCP 的可靠传输，等收到这个数据包的 ACK 时，才会释放原始的 sk_buff
3. 第三次，当IP 层发现 sk_buff 大于 MTU 时才需要进行。会再申请额外的 sk_buff，并将原来的 sk_buff 拷贝为多个小的 sk_buff。

## HTTP缓存 有哪些？

两种，**强制缓存和协商缓存**。

**强制缓存：**只要浏览器判断缓存没有过期，直接用浏览器的本地缓存，浏览器决定用不用缓存。强缓存利用HTTP 响应头里的字段实现：

- `Cache-Control`， 相对时间；
- `Expires`，绝对时间；

**协商缓存：**协商缓存就是与服务端协商之后，通过协商结果来判断是否使用本地缓存。请求的响应码是 `304`，就是浏览器可以使用本地缓存的资源。**需要配合强制缓存中 Cache-Control 字段来使用，只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求**。

## HTTPS一定安全吗？如果有中间的假基站转发了消息怎么办？

自己不乱点，正常情况下是安全的。中间的假基站会给客户端发送证书的，浏览器会提示假基站的证书不安全。

但是如果电脑中毒了，被导入了中间人的根证书，那么等中间人的证书是合法的，这种情况下，浏览器是不会弹出证书存在问题的风险提醒的。

## HTTP1.1优点

1. **简单：**       HTTP 基本的报文格式就是 `header + body`，头部信息也是 `key-value` 简单文本的形式

2. **灵活和易于扩展：**     请求方法、URI/URL、状态码、头字段 都没有被固定死，可以自定义和扩充

3. **应用广泛和跨平台：**   HTTP 的应用范围非常的广泛，pc端浏览器和手机上的APP都用。
4. **和1.0对比： **  用了长连接

## HTTP1.1缺点

1. **没有状态**：  不能记录状态信息，可以用cookie解决。
2. **明文传输，不安全：**    通信使用明文，不验证通信方的身份，不能证明报文的完整性
3. **队头阻塞：**    服务端在处理 一个请求时耗时比较长，后面的请求的处理会被阻塞住， **HTTP/1.1 管道解决了请求的队头阻塞**，但是浏览器基本上默认关闭。

## HTTP1.1 相比 HTTP/1.0 提高了什么性能？

- 使用长连接的方式改善了 HTTP/1.0 短连接造成的性能开销。
- 支持管道（pipeline）网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。

## HTTP1.1如何优化？

1. **避免发送HTTP请求：**       用缓存
2. **减少HTTP请求次数：**    **减少重定向的请求次数：**重定向的工作让代理服务器完成。   **合并请求：**把多个访问小文件的请求合并成一个大的请求，可以减少重复发送HTTP头。   **延迟发送请求：**请求网页的时候，只获取一部分，当用户下滑的时候再请求资源。
3. **减少HTTP响应的数据大小：**   可以对相应的资源进行压缩，一般有无损压缩和有损压缩。无损压缩常见的有gzip。有损压缩会把不重要的数据舍弃，牺牲一些质量来减少数据量、提高压缩比，经常用于压缩多媒体数据，音频、视频、图片。

## HTTP2.0优化了什么？

- **头部压缩：**     用到HPACK算法，就是在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号。静态表只包含了高频出现在头部的字符串，不在静态表里的头部字符串要构建**动态表**，会在编码解码的时候随时更新。
- **二进制格式：**   1.1是纯文本形式的报文，2.0用是**二进制格式**。头信息和数据体都是二进制，头信息帧和数据帧。
- **并发传输：**   用了 Stream 概念，多个 Stream 复用在一条 TCP 连接，不同的 HTTP 请求用 Stream ID 来区分。可以解决一部分队头阻塞问题，但是不能完全解决，因为底层还是TCP。
- **服务器主动推送：**   服务端可以主动向客户端发送消息，可以建立stream

## HTTP3.0做了什么优化？

- **解决了队头阻塞问题：**    因为底层是tcp，就会有队头阻塞问题，HTTP3.0使用了quic协议，是基于udp的。
- **建立连接更快：**     HTTP3.0的QUIC协议包含了TLS，会携带 TLS 里的内容，如果是TLS1.2，需要1个RTT就能完成建立连接和密钥协商。
- **连接迁移：**  基于 TCP 传输协议的 HTTP 协议，是通过四元组确定一条 TCP 连接，切换网络的时候，**要断开连接，然后重新建立连接**。QUIC协议通过连接ID标记一个连接，切换网络的时候可以复用原连接。
- **二级制格式：**   与2.0一样采用二进制帧的结构， HTTP/2 的二进制帧里需要定义 Stream，而HTTP/3 自身不需要再定义 Stream，直接使用 QUIC 里的 Stream。

## HTTPS如何优化？  TODO

## 有HTTP，为什么还要RPC？

- 纯裸 TCP 能收发数据，但是是没有边界**的数据流，上层需要定义**消息格式**用于定义**消息边界。所以就有了各种协议，HTTP 和各类 RPC 协议就是在 TCP 之上定义的应用层协议。
- **RPC 本质上不算是协议，而是一种调用方式**，而像 gRPC 和 这样的具体实现，才是协议，它们是实现了 RPC 调用的协议。目的是能像调用本地方法那样去调用远端的服务方法。
- 很多软件同时支持多端，所以对外一般用 HTTP 协议，而内部集群的微服务之间则采用 RPC 协议进行通讯。

## 扫码登陆如何实现？

**用HTTP定时轮询：**登录页面二维码出现之后，**前端**网页根本不知道用户扫没扫，不断去向**后端**服务器询问。如果间隔1~2秒发送请求会消耗带宽。所以用**长轮询**，发出请求后，给服务器留时间去响应，**只要服务器收到了扫码请求，就立马返回给客户端网页。如果超时，就立马发起下一次请求。**

## websocket

适用于**需要服务器和客户端（浏览器）频繁交互**的大部分场景，比如网页/小程序游戏，网页聊天室，以及一些类似飞书这样的网页协同办公软件。

**如何建立websocket连接？**

浏览器在 **TCP 三次握手**建立连接之后，**使用 HTTP 协议**先进行一次通信。

- 如果是**普通的 HTTP 请求**，那后续双方继续用普通 HTTP 协议进行交互。
- 如果**想建立 WebSocket 连接**，就会在 HTTP 请求里带上一些**特殊的header 头**，代表升级协议，然后服务端的响应为101。一来一回两次HTTP握手，websocket就建立完成了

## TCP头格式

<img src="./assets/tcp头格式.png" alt="tcp头格式" style="zoom:50%;" />

