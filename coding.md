# MySQL

## MySQL中的NULL值是怎么存放的

在经典的compact行存储格式中，会使用NULL值列表来标记值为NULL的列，NULL值并不会存储在行格式中的真实数据部分，NULL值列表会占用一个字节空间，当有列为NULL时会设置标记，当所有列都是非NULL的就不会再有这1字节的NULL值列表

## MySQL中的varchar(n)实际占用数据大小

varchar(n)类型需要标记一下真实占用空间大小，因此和NULL值列表一样，有个变长字段大小列表，当没有变长字段的时候就不存储了，存储的列信息都倒放的，为了利好cpu，可以一次读出列信息和真实数据

## 行溢出后会怎么样

MySQL中一行数据最多能存储65535个字节，但是一页也就16k，因此有可能会有可能一页存不了一条行记录，这时候就会出现溢出页来存储，compact格式在溢出的时候，本身会存储一部分数据，剩余的部分存储在溢出页中，compressed/dynamic是仅存储数据的地址，不存储部分数据

compact
![compact行结构](./assets/compactLine.png)
compressed/dynamic
![compressed/dynamic行结构](./assets/compressedLine.png)

## MySQL的索引分类

![MySQL索引分类](./assets/mysqlIndex.png)

## MySQL索引优化

- **前缀索引优化**
  - 只对字段的前n个字符建立索引，减少索引项大小
  - 无法sort
  - 无法覆盖索引
- **覆盖索引优化**
  - 查询的所有字段都在索引上，避免了回表
- **主键自增**
  - 添加纪录的时候顺序添加，无需做多余的页分裂操作
- **索引设置NOT NULL**
  - 只要列中包含有 NULL 值都将不会被包含在索引中，复合索引中只要有⼀列含NULL值，那么这⼀列对于此复合索引就是⽆效的。
- **避免索引失效**
  - 左模糊查询
  - 对索引进行函数计算
  - 隐式转换
  - or后不是索引

## 什么时候需要/不需要创建索引

### 需要
  
- 字段唯一限制
- 经常用于where的，不是一个字段的需要建立联合索引
- 经常group/order by的，索引会排序

### 不需要

- where/group/order都用不到的
- 字段有很多重复数据，区分度不明显
- 表数据很少
- 经常更新的字段，需要维护红黑树的特性

## MySQL单表不要超过2000w行

记录条数计算公式,x代表一页能存储多少索引记录，y表示一页能存储多少条数据记录，x大约是1000左右z一般是3行，y的差不多15左右，差不多两千万行，一般z都是3层左右，再多就会影响查询性能
$$
Total = x ^ {z-1} * y
$$

## MySQL使用like "%x"，索引就一定失效吗

不一定，当要检索的字段全部在索引中时，就会直接遍历二级索引，来走覆盖索引，也就属于走索引了。比如下面的例子，题目二就是这样，下面的四条sql语句全部走索引

![索引失效特例图](./assets/mysqlSpecial.png)

## MySQL中count(*)和count(1)哪个性能好

**count(主键字段)** 会先便利主键值，判断主键值是不是NULL，如果不是NULL就将count变量加一，当表里有二级索引的时候，就会走二级索引，因为二级索引相对聚簇索引需要的io更少

**count(1)** 也会便利主键索引，但是不会读取主键的内容，因为count的参数就是1，因此不需要判断是否有NULL值的存在

**count(\*)** 其实等于count(0)，就和count(1)一样

**count(普通字段)** 是性能最差的，因为需要全表扫描

### 为啥要通过遍历方式来计数

MyISAM引擎使用count(*)，只需要O(1)的复杂度，因为每张MyISAM的表数据都有一个meta信息有存储count值，由表级锁来保持一致性

InnoDB存储引擎支持事务，同一时刻查询由多版本并发控制(MVCC)控制，InnoDB表应该返回多少行也是不确定的，所以不行

### 如何优化count(*)

- 使用近似值 explain
- 额外的表保存计数值

## MVCC 中的Read View的工作原理

**m_ids:** 表示启动了还没有提交的事务
**min_trx_id:** 活跃事务中id最小的业务
**max_trx_id:** 当前数据库给下一个事务分配的事务id
**creator_trx_id:** 创建该read view的事务id

加上记录行的两个隐藏列，trx_id(事务对其改动时，记录其id)和roll_pointer回滚指针

**可重复读** 就是在事务启动的时候创建一个read view，整个事务中保持一个
**读已提交** 就是在每个sql查询的时候创建一个read view

![Read View](./assets/readView.png)

## MySQL可重复读隔离级别，完全解决了幻读了吗

当快照读的时候，读了某个记录，然后另一个事务更改了记录，然后本事务当前读就不可重复读了。
